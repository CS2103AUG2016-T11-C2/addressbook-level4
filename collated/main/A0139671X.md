# A0139671X
###### /java/seedu/forgetmenot/logic/commands/EditCommand.java
``` java
/**
 * Edits a task identified using it's last displayed index from the task manager.
 */
public class EditCommand extends Command {
    
    public static final String COMMAND_WORD = "edit";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the task identified using it's last displayed index. "
            + "Parameters: INDEX PROPERTY NEW_INPUT\n"
            + "Example: " + COMMAND_WORD 
            + " 1 name oranges";
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "You've successfully editted the task!\n"
            + "Editted Task: %1$s";
    public static final String MESSAGE_EDIT_TASK_NOT_SUCCESSFUL = "Sorry! The edit details are invalid. Please try again.";
    
    private int targetIndex;
    private String newName;
    private String newStart;
    private String newEnd;
    
    public EditCommand(String targetIndex, String name, String start, String end) {
        this.targetIndex = Integer.parseInt(targetIndex);
        this.newName = name;
        this.newStart = start;
        this.newEnd = end;
    }

    @Override
    public CommandResult execute() {
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        
        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);

        try {
            
            // checks that new start time must be before end
            if (newStart != null && !taskToEdit.getEndTime().isMissing() && !Time.checkOrderOfDates(newStart, taskToEdit.getEndTime().appearOnUIFormat()))
                return new CommandResult(Messages.MESSAGE_INVALID_START_AND_END_TIME);
            
            // checks that the new end time must be after start
            if (newEnd != null && !taskToEdit.getStartTime().isMissing() && Time.checkOrderOfDates(newEnd, taskToEdit.getStartTime().appearOnUIFormat()))
                return new CommandResult(Messages.MESSAGE_INVALID_START_AND_END_TIME);
            
            // checks that the new start and end time are valid
            if (newEnd != null && newStart != null && !Time.checkOrderOfDates(newStart, newEnd))
                return new CommandResult(Messages.MESSAGE_INVALID_START_AND_END_TIME);
            
            model.saveToHistory();
            model.editTask(taskToEdit, newName, newStart, newEnd);
            model.updateFilteredTaskListToShowNotDone();
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        } catch (IllegalValueException e) {
            return new CommandResult(MESSAGE_EDIT_TASK_NOT_SUCCESSFUL);
        }
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }
    
}
```
###### /java/seedu/forgetmenot/logic/commands/RedoCommand.java
``` java
/**
 * Redoes an undo action.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redoes the most recent command in ForgetMeNot. "
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Command redone! Your recent undo was undone.";
    public static final String MESSAGE_REDO_INVALID = "There is nothing to redo.";
    
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.loadFromUndoHistory();
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (NoSuchElementException e) {
            return new CommandResult(MESSAGE_REDO_INVALID);
        }
    }   

}
```
###### /java/seedu/forgetmenot/logic/commands/UndoCommand.java
``` java
/**
 * Undoes a task-modifying action
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undoes the most recent command in ForgetMeNot. "
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Your recent command was undone!";
    public static final String MESSAGE_UNDO_INVALID = "There were no recent commands to be undone. ";
    
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.loadFromHistory();
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (NoSuchElementException e) {
            return new CommandResult(MESSAGE_UNDO_INVALID);
        }
    }   

}
```
###### /java/seedu/forgetmenot/logic/parser/Parser.java
``` java
    private Command prepareEdit(String args) {
        final Matcher matcher = TASK_EDIT_ARGS_FORMAT.matcher(args.trim());
        String name, startTime, endTime;
        
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        } else {
            name = (matcher.group("name") == null) ? null : matcher.group("name");
            startTime = (matcher.group("start") == null) ? null : matcher.group("start");
            endTime = (matcher.group("end") == null) ? null : matcher.group("end");
        }
        
        return new EditCommand(matcher.group("index"), name, startTime, endTime);
    }

```
###### /java/seedu/forgetmenot/model/ModelManager.java
``` java
    /**
     * Clears the stored tasks managers from both undo deque and task manager deque
     */
    public void clearHistory() {
        taskManagerHistory.clear();
        undoHistory.clear();
    }

    /**
     * Saves a copy of the current task manager to a deque
     */
    @Override
    public void saveToHistory() {
        taskManagerHistory.push(new TaskManager(taskManager));
        undoHistory.clear();
    }
    
    /**
     * Loads a copy of the most recent task manager and updates the count of tasks in ForgetMeNot
     */
    @Override
    public void loadFromHistory() throws NoSuchElementException {
        TaskManager oldManager = taskManagerHistory.pop();
        undoHistory.push(new TaskManager(taskManager));
        taskManager.setTasks(oldManager.getTasks());
        taskManager.counter();
        indicateTaskManagerChanged();
    }
    
    /**
     * Loads a copy of the most recent undone task manager
     */
    @Override
    public void loadFromUndoHistory() throws NoSuchElementException {
        TaskManager oldManager = undoHistory.pop();
        taskManagerHistory.push(new TaskManager(taskManager));
        taskManager.setTasks(oldManager.getTasks());
        taskManager.counter();
        indicateTaskManagerChanged();
    }
```
###### /java/seedu/forgetmenot/model/ModelManager.java
``` java
    /**
     * Adds a task to the task manager and auto jumps to the most recent add in ForgetMeNot UI
     */
    @Override
    public synchronized void addTask(Task task) {
        taskManager.addTask(task);
        updateFilteredTaskListToShowNotDone();
        indicateTaskManagerChanged();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(filteredTasks.indexOf(task)));
    }

    /**
     * Adds a recurring task with either the default occurence or the specified occurence 
     * with a specified frequency
     */
    @Override
    public synchronized void addRecurringTask(ReadOnlyTask task) throws IllegalValueException {
        String freq = task.getRecurrence().getRecurFreq();
        int occur = task.getRecurrence().getOccurence();

        // Recurring task with only start time.
       if (task.isStartTask())
            addRecurringTaskWithStartOnly(task, freq, occur);

       // Recurring task with only end time.
       else if (task.isDeadlineTask()) 
           addRecurringDeadline(task, freq, occur);
       
        // Recurring task with both start and end times
        else if (task.isEventTask()) 
            addRecurringEvent(task, freq, occur);

        updateFilteredTaskListToShowNotDone();
        indicateTaskManagerChanged();
    }

    public void addRecurringEvent(ReadOnlyTask task, String freq, int occur) throws IllegalValueException {
        StringBuilder recurStartTime = new StringBuilder(task.getStartTime().appearOnUIFormat());
        StringBuilder recurEndTime = new StringBuilder(task.getEndTime().appearOnUIFormat());
        for (int i = 0; i < occur - 1; i++) {
            recurStartTime.insert(0, freq + " after ");
            recurEndTime.insert(0, freq + " after ");
            addTask(new Task(task.getName(), new Done(false), new Time(recurStartTime.toString()),
                    new Time(recurEndTime.toString()), new Recurrence(task.getRecurrence().getRecurFreq())));
        }
    }

    public void addRecurringDeadline(ReadOnlyTask task, String freq, int occur) throws IllegalValueException {
        StringBuilder recurEndTime = new StringBuilder(task.getEndTime().appearOnUIFormat());
           for (int i = 0; i < occur - 1; i++) {
               recurEndTime.insert(0, freq + " after ");
               addTask(new Task(task.getName(), new Done(false), new Time(""), new Time(recurEndTime.toString()),
                       new Recurrence(task.getRecurrence().getRecurFreq())));
           }
    }

    public void addRecurringTaskWithStartOnly(ReadOnlyTask task, String freq, int occur) throws IllegalValueException {
        StringBuilder recurStartTime = new StringBuilder(task.getStartTime().appearOnUIFormat());
        for (int i = 0; i < occur - 1; i++) {
            recurStartTime.insert(0, freq + " after ");
            addTask(new Task(task.getName(), new Done(false), new Time(recurStartTime.toString()), new Time(""),
                    new Recurrence(task.getRecurrence().getRecurFreq())));
        }
    }
    /**
     * Edits a tasks with the new details given and auto selects the editted task in ForgetMeNot UI
     */
    @Override
    public synchronized void editTask(ReadOnlyTask task, String newName, String newStart, String newEnd
            ) throws TaskNotFoundException, IllegalValueException {
        if (newName != null)
            taskManager.editTaskName(task, newName);

        if (newStart != null)
            taskManager.editTaskStartTime(task, newStart);

        if (newEnd != null)
            taskManager.editTaskEndTime(task, newEnd);

        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        EventsCenter.getInstance().post(new JumpToListRequestEvent(filteredTasks.indexOf(task)));
    }
```
###### /java/seedu/forgetmenot/model/task/ReadOnlyTask.java
``` java
    /**
     * Formats the task as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        
        builder.append(getName());
        builder.append(System.lineSeparator());
        
        if (!getStartTime().isMissing())
            builder.append("Start: " + getStartTime().easyReadDateFormatForUI());
        
        if (!getEndTime().isMissing())
            builder.append(" End: " + getEndTime().easyReadDateFormatForUI());
        
        if (getRecurrence().getValue())
            builder.append(" Recurrence: " + getRecurrence());
        
        return builder.toString();
    }

}
```
###### /java/seedu/forgetmenot/model/task/Recurrence.java
``` java
 */
public class Recurrence {

    public static final int DEFAULT_OCCURENCE = 10;
    
    private static final Pattern RECURRENCE_DATA_ARGS_FORMAT = Pattern.compile("(?<freq>((\\d* )?(day|week|month|year)(s)?))"
            + "( x(?<occ>(\\d++)))?", Pattern.CASE_INSENSITIVE);

    private boolean value;
    public String days;
    public int occurences;
    
    public Recurrence (String args) throws IllegalValueException {
        final Matcher matcher = RECURRENCE_DATA_ARGS_FORMAT.matcher(args.trim());
        
        if (args.equals("")) {
            this.days = "";
            this.value = false;
            this.occurences = 0;
        }
        
        else if (!matcher.matches()) {
            throw new IllegalValueException("Sorry! Your recurrence format was invalid! Please try again.");
        }
        
        else {
            assignRecurrenceValues(args, matcher);
        }
    }

    
    public boolean getValue() {
        return this.value;
    }
    
    public String getRecurFreq() {
        System.out.println(this.days);
        return this.days;
    }

    public void setRecurFreq(String days) {
        this.days = days;
    }
    
    public int getOccurence() {
        return this.occurences;
    }
    
    @Override
    public String toString() {
        if (!value)
            return "NIL";
        if (days.toLowerCase().equals("day"))
            return "Daily";
        if (days.toLowerCase().equals("week"))
            return "Weekly";
        if (days.toLowerCase().equals("month"))
            return "Monthly";
        if (days.toLowerCase().equals("year"))
            return "Yearly";
        
        return days;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Recurrence // instanceof handles nulls
                && this.days.equals(((Recurrence) other).days)); // state check
    }
    
    @Override
    public int hashCode() {
        return days.hashCode();
    }
    
    /**
     * Assigns the recurrence attributes to follow either a default occurence or a assigned occurence by the user 
     */
    private void assignRecurrenceValues(String recurrenceString, final Matcher matcher) {
        
        if(!recurrenceString.contains("x")) {
            this.occurences = DEFAULT_OCCURENCE;
        }
        else {
            this.occurences = Integer.parseInt(matcher.group("occ").trim());
        }

        this.days = matcher.group("freq");
        this.value = true;
    }

}
```
###### /java/seedu/forgetmenot/model/task/Task.java
``` java
    @Override
    public String toString() {
        return getAsText();
    }
    
    /**
     * @return true if the tasks is past the current time.
     */
    public boolean checkOverdue() {
        if (isDeadlineTask())
            return end.time.compareTo(Calendar.getInstance()) < 0;
        
        else if (isStartTask() || isEventTask())
            return start.time.compareTo(Calendar.getInstance()) < 0;
        
        return false;
    }
    
    /**
     * Checks if a task is an event, i.e. a start time and an end time.
     * @return true if task has both start and end time.
     */
    public boolean isEventTask() {
        return !start.isMissing() && !end.isMissing();
    }
    /**
     * Checks if a task is a start time event, i.e. only has start time.
     * @return true if only start time is present for the task.
     */
    public boolean isStartTask() {
        return !start.isMissing() && end.isMissing();
    }
    
    /**
     * Checks if a task is a deadline, i.e. only has an end time.
     * @return true if only end time is present.
     */
    public boolean isDeadlineTask() {
        return start.isMissing() && !end.isMissing();
    }
    
    /**
     * Checks if a task is a floating task, i.e. no start time and no end time.
     * @return true if both start and end times are not present.
     */
    public boolean isFloatingTask() {
        return start.isMissing() && end.isMissing();
    }
```
###### /java/seedu/forgetmenot/model/task/Time.java
``` java
     */
    public String easyReadDateFormatForUI() {
        if(time.getTime().equals(new Date(0))) {
            return "-";
        }
        
        else {
            SimpleDateFormat dateFormatter = new SimpleDateFormat("E, MMM d, yyyy, hh:mm a");
            return dateFormatter.format(time.getTime());
        }
        
    }
    
```
###### /java/seedu/forgetmenot/model/task/UniqueTaskList.java
``` java
    public void editName(ReadOnlyTask toEdit, Name newName) throws TaskNotFoundException {
        assert toEdit != null;
        if(!internalList.contains(toEdit))
            throw new TaskNotFoundException();
        int taskIndex = internalList.indexOf(toEdit);
        Task taskFound = internalList.get(taskIndex);
        taskFound.setName(newName);
        internalList.set(taskIndex, taskFound);
    }
    
```
###### /java/seedu/forgetmenot/model/task/UniqueTaskList.java
``` java
    public void editStartTime(ReadOnlyTask toEdit, Time newTiming) throws TaskNotFoundException {
        assert toEdit != null;
        if(!internalList.contains(toEdit))
            throw new TaskNotFoundException();
        int taskIndex = internalList.indexOf(toEdit);
        Task taskFound = internalList.get(taskIndex);
        taskFound.setStartTime(newTiming);
        internalList.set(taskIndex, taskFound);
    }
    
```
###### /java/seedu/forgetmenot/model/task/UniqueTaskList.java
``` java
    public void editEndTime(ReadOnlyTask toEdit, Time newTiming) throws TaskNotFoundException {
        assert toEdit != null;
        if(!internalList.contains(toEdit))
            throw new TaskNotFoundException();
        int taskIndex = internalList.indexOf(toEdit);
        Task taskFound = internalList.get(taskIndex);
        taskFound.setEndTime(newTiming);
        internalList.set(taskIndex, taskFound);
    }
    
```
###### /java/seedu/forgetmenot/model/task/UniqueTaskList.java
``` java
    public void editRecurFreq(ReadOnlyTask toEdit, Recurrence newRec) throws TaskNotFoundException {
        assert toEdit != null;
        if(!internalList.contains(toEdit))
            throw new TaskNotFoundException();
        int taskIndex = internalList.indexOf(toEdit);
        Task taskFound = internalList.get(taskIndex);
        taskFound.setRecurrence(newRec);
        internalList.set(taskIndex, taskFound);        
    }
```
###### /java/seedu/forgetmenot/model/TaskManager.java
``` java
    public void editTaskName(ReadOnlyTask task, String newInfo)
            throws UniqueTaskList.TaskNotFoundException, IllegalValueException {
        tasks.editName(task, new Name(newInfo));
        counter();
    }

    public void editTaskStartTime(ReadOnlyTask task, String newInfo)
            throws UniqueTaskList.TaskNotFoundException, IllegalValueException {
        tasks.editStartTime(task, new Time(newInfo));
        counter();
    }

    public void editTaskEndTime(ReadOnlyTask task, String newInfo)
            throws UniqueTaskList.TaskNotFoundException, IllegalValueException {
        tasks.editEndTime(task, new Time(newInfo));
        counter();
    }
```
